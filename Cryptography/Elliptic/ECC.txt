> # Демонстрация реализации в системе аналитических вычислений
> # Maple (в простом поле Галуа GF(p)):
> #
> #  (1) операции сложения точек эллиптической кривой;
> #  (2) операции удвоения точки эллиптической кривой;
> #  (3) операции умножения точки эллиптической кривой на число.
> #
> # Автор неизвестен (благодарим его за код)...
> # Адаптация, дополнения и исправление ошибки в процедуре p_Mul:
> # М.В.Швецкий (03.09.2020, 05:30-17:50;
> #              10.12.2020, 15:00-21:49)
> #
> # ***************************************************
> # Процедура для сложения  р а з л и ч н ы х  точек P1
> # и P2 эллиптической кривой с модулем p, p>1
> # ------------------------------------------
> sum_Point:=proc(P1, P2, p)
>   local x1,y1,x2,y2,x3,y3,lambda,P3:
>   x1:=P1[0]: y1:=P1[1]: x2:=P2[0]: y2:=P2[1]:
>   if (x1=0 and y1=0) 
>     then x3:=x2: y3:=y2:
>     else if (x2=0 and y2=0)
>            then x3:=x1: y3:=y1:
>            else if (x1=x2 and y1=(-y2) mod p)
>                   then x3:=0: y3:=0:
>                   else lambda:=(y2-y1)/(x2-x1) mod p:
>                        x3    :=(lambda^2-x1-x2) mod p:
>                        y3    :=(lambda*(x1-x3)-y1) mod p:
>                 end if:
>          end if:
>   end if:
>   P3:=array(0..1,[x3,y3]):
> end:
> #
> # *****************************************************
> # Процедура для удвоения точки P1 эллиптической кривой;
> # результатом является точка P3=[2]P1
> # -----------------------------------
> double_Point:=proc(P1, p, a)
>   local x1,y1,x3,y3,lambda,P3:
>   x1:=P1[0]: y1:=P1[1]:
>   if (y1=0)
>     then x3:=0: y3:=0:
>     else lambda:=((3*x1^2+a)/2/y1)   mod p:
>          x3    :=(lambda^2-2*x1)     mod p:
>          y3    :=(lambda*(x1-x3)-y1) mod p:
>   end if:
>   P3:=array(0..1,[x3,y3]):
> end:
> #
> # ********************************************************
> # Процедура для выполнения умножения точки P эллиптической
> # кривой на целое число d; результатом является Q=[d]P:
> #  P - точка на эллиптической кривой;
> #  d - множитель (ц е л о е  число);
> #  p - модуль    (н а т у р а л ь н о е  число, >1);
> #  a - коэффициент при x в уравнении эллиптической кривой
> # -------------------------------------------------------
> p_Mul:=proc(P, d, p, a)
>   local N,i,Q,xqs,yqs,d1;
>   if (d>0)
>     then Q:=P;
>          N:=convert(d,binary); N:=convert(N,string);
>          for i from 2 to length(N) do
>            Q:=double_Point(Q,p,a):
>            if (N[i]="1")
>              then if (Q[0]=P[0] and Q[1]=P[1])
>                    then Q:=double_Point(Q,p,a):
>                     else Q:=   sum_Point(Q,P,p): 
>                   end if:
>            end if:
>          end do:
>          RETURN(array(0..1,[Q[0],Q[1]])):
>     else d1:=-d;
>          Q:=P;
>         N:=convert(d1,binary); N:=convert(N,string);
>          for i from 2 to length(N) do
>            Q:=double_Point(Q,p,a):
>            if (N[i]="1")
>              then if (Q[0]=P[0] and Q[1]=P[1])
>                     then Q:=double_Point(Q,p,a):
>                     else Q:=   sum_Point(Q,P,p): 
>                   end if:
>            end if:
>          end do:
>          RETURN(array(0..1,[Q[0],-Q[1]])):
>   end if:
> end:
> #
> #
> # ===========================================
> # Определение эллиптической кривой E   (-1,1)
> #                                   751
> # y^2 = x^3 - x + 1, a=-1, b=1, p=751
> # -----------------------------------
> p:=751; ka:=-1; kb:=1;
> # 
> # ========================================================
> # Вывод  в с е х  целочисленных точек (вместе с бесконечно
> # удалённой точкой) эллиптической кривой E (a,b)
> #                                         p
> # ("б а з а  д а н н ы х" точек кривой) 
> # ---------------------------------------
> w  := msolve(y^2 = x^3 + ka * x + kb, p):
> NE := 1 + nops([w]); print(\n\n);
> #
> # ==============================================
> # Выполнение  с л о ж е н и я  различных точек P
> # и Q эллиптической кривой E (ka,kb)
> #                           p
> # -------------------------------------------------
> P1:=array(0..1,[69,510]): Q1:=array(0..1,[53,277]):
> res1:=sum_Point(P1,Q1,p):
> print("Результат сложения точек: ",res1[0],res1[1]); print(\n\n);
> #
> #
> # ===============================================
> # Выполнение  у м н о ж е н и я  точки P на целое
> # число m (скалярного произведения [m]P)
> # [Жданов,Чалкин,2012,с.142-143,N30]:
> #
> P1:=array(0..1,[58,139]): m:=124: 
> res2:=p_Mul(P1,m,p,ka): 
> print("Результат умножения: ",res2[0],res2[1]); print(\n\n);
> #
> #
> # ================================
> # Демонстрация выполнения операции 
> #
> #  [2]P+[3]Q+[-1]R 
> #
> # для точек P, Q, R эллиптической кривой E (ka,kb)
> #                                         p
> # [Жданов,Чалкин,2012,с.141-142,N25]
> #
> P1:=array(0..1,[69,510]): Q1:=array(0..1,[53,277]):  
>                           R1:=array(0..1,[105,369]):
> y1:=p_Mul(P1,2,p,ka): y2:=p_Mul(Q1,3,p,ka): 
>                       y3:=p_Mul(R1,-1,p,ka):
> res3:= sum_Point(sum_Point(y1,y2,p),y3,p): 
> print("Результат выполнения операции: ",res3[0],res3[1]);
> print(\n\n);
> #
> #
> # ===================================================
> # Вычисление  п о р я д к а  точки эллиптической кри-   
> # вой Ep(ka,kb) с заданным номером l в списке [w]
> # -----------------------------------------------------------
> with(numtheory):
> # ---------------
> l:=NE-20; # for l from NE-20 to NE-1 do ... end do:
> assign(w[l]):         
> P2:=array(0..1,[x,y]):     # Либо генератор, чтобы вычислить порядок подгруппы
> # ---------------
> Di:=divisors(NE):          # Делители NE
> for n in Di do
>   z:=p_Mul(P2, n, p, ka):
>   cond:=verify(z[0], 0, 'equal') and verify(z[1], 0, 'equal'):
>   if cond then
>     break;
>   end if:
> end do:
> printf("Точка (%3d, %3d), её номер %3d ",x,y,l);
> printf("и порядок: %3d\n",n);
> x := 'x': y := 'y':
> #
> #
> # ===================================================
> # Вычисление генератора (базовой точки) в Ep(ka,kb)
> # -----------------------------------------------------------
> with(numtheory):
> # ---------------
> n:=factorset(NE)[-1]:     # Порядок подгруппы
> h:=NE/n:                  # Кофактор
> while true do
>   assign(w[rand(1..NE-1)()]):
>   P2:=array(0..1, [x,y]): # Случайная точка
>   G:=p_Mul(P2, h, p, ka):
>   cond:=verify(G[0], 0, 'equal') and verify(G[1], 0, 'equal'):
>   x := 'x': y := 'y':
>   if not cond then
>     break;
>   end if:
> end do:
> printf("Генератор (%3d, %3d), кофактор %3d ",G[0],G[1],h);
> printf("и порядок: %3d\n",n);
> printf("Проверка генератора:");
> for i from 1 to n do
>   p_Mul(G, i, p, ka);
> end do;
> #
> #
                                     751
                                     -1
                                      1
                                     728

                    "Результат сложения точек: ", 93, 267

                      "Результат умножения: ", 618, 545

                 "Результат выполнения операции: ", 685, 96

                                     708
Точка (726, 143), её номер 708 и порядок: 728
Генератор (135, 669), кофактор  56 и порядок:  13
Проверка генератора:













> 
